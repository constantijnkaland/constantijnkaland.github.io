# General information
# This script measures time-series f0 using the R package PraatR. The functionality is identical to time-series_F0.praat, which uses the Praat scripting interface. The output is a comma separated csv file.
# A theoretical motivation is given in the accompanying paper. 
# Usage guidelines are given in the accompanying manual.
# Constantijn Kaland, March 2021.
# https://constantijnkaland.github.io/contourclustering/

#### set variables ####

# directory where both wave-files and textgrids are stored ["P:/ath/to/dir/"]
wavdir = "P:/"

# working directory; this is where the data will be written as csv-file (AUTO means directory of this script) ["P:/ath/to/dir/"]
workdir = "AUTO"

# name of the output file (must include file extension .csv) [abc123.csv]
output = "output.csv"

# tier with the intervals for which contours should be analysed ["tiername"]
tier = "tx"

# desired duration range (min and max in seconds) [a number]
durmin = 0.6
durmax = 0.8

# fo analysis parameters (timestep, minimum f0, maximum f0)
timestep = 0.01
minf0 = 75
maxf0 = 500

# kill octave jumps [1] or not [0]
killjumps = 1

# stylisation resolution in semitones [a number]
stylres = 1

# number of measures to take for each contour [a number]
nummeas = 20


#### install and load required packages, please check for details on PraatR: http://www2.kobe-u.ac.jp/~albin/praatr/index.html ####
# make sure Praat.exe is copied to the PraatR directory!
install.packages("devtools")
devtools:::install_github("usagi5886/PraatR")
library("PraatR")

if (workdir == "AUTO") {
  if (!require("rstudioapi")) install.packages("rstudioapi")
  library(rstudioapi)
  current_path = rstudioapi::getActiveDocumentContext()$path
  setwd(dirname(current_path))
} else {
  setwd(workdir)
}

#### measure f0 ####

# list the wave-files in the specified directory and get names
list.files(wavdir, "*.wav") -> wavlist
substr(wavlist,1,nchar(wavlist)-4) -> wavlist

# create empty dataframe with column names, which correspond to the column names generated by the Praat-script
data <- data.frame(F = character(0), SL=character(0), S=numeric(0), E=numeric(0), St=numeric(0),StN=numeric(0),f0=numeric(),J=numeric(0), stringsAsFactors=F)
colnames(data) <- c("filename","interval_label","start","end","step","stepnumber","f0","jumpkilleffect")

# go through all wave-files in the specified directory and proceed when a corresponding textgrid is found
for (wav in wavlist){
  if (file.exists(paste(wavdir,wav,".textgrid",sep=""))){
    # get tiernumber matching the specified tiername
    numtiers = as.numeric(praat(command = "Get number of tiers", input=paste(wavdir,wav,".textgrid",sep=""), simplify = TRUE))
    tiernum = 0
    repeat {
      tiernum = tiernum+1
      tiername = praat(command = "Get tier name...", arguments = list(tiernum), input = paste(wavdir,wav,".textgrid",sep=""))
      if (tiername == tier) {
        break
      }
    }
    # get number if intervals in the specified tier
    numint = as.numeric(praat(command = "Get number of intervals...",arguments = list(tiernum), input=paste(wavdir,wav,".textgrid",sep=""),simplify = TRUE))
    seq(from = 1, to = numint) -> ints
    # for each interval get label, starttime and endtime, and calculate duration
    for (int in ints){
      label = praat(command = "Get label of interval...",arguments = list(tiernum,int), input=paste(wavdir,wav,".textgrid",sep=""))
      start = as.numeric(praat(command = "Get start point...", arguments = list(tiernum,int), input=paste(wavdir,wav,".textgrid",sep=""), simplify = TRUE))
      end = as.numeric(praat(command = "Get end point...", arguments = list(tiernum,int), input=paste(wavdir,wav,".textgrid",sep=""), simplify = TRUE))
      dur = end-start
      # check if label is non-empty and proceed when interval duration lies within specified duration range
      if (label != "" && dur >= durmin && dur <= durmax){
        # show which filename and interval label are processed
        print(paste(c(wav,label), sep = "\t"))
        # extract interval from wavefile and convert to pitch object
        praat("Extract part...",list(start,end,"rectangular",1,"no"),paste(wavdir,wav,".wav",sep=""),paste(wavdir,round(start,2),".wav",sep=""))
        praat("To Pitch...", list(timestep,minf0,maxf0),paste(wavdir,round(start,2),".wav",sep=""),paste(wavdir,round(start,2),".pitch",sep=""))
        # if specified, kill octave jumps and measure mean f0 before and after the killing
        octeff = 0
        if (killjumps == 1) {
          morg = as.numeric(praat("Get mean...", list(0,0,"Hertz"),input = paste(wavdir,round(start,2),".pitch",sep=""),simplify = TRUE))
          praat(command = "Kill octave jumps", input = paste(wavdir,round(start,2),".pitch",sep=""), output = paste(wavdir,round(start,2),".pitch",sep=""),overwrite = TRUE)
          moct = as.numeric(praat("Get mean...", list(0,0,"Hertz"),input = paste(wavdir,round(start,2),".pitch",sep=""),simplify = TRUE))
          octeff = morg/moct
        }
        # convert pitch object to pitch tier and stylise it
        praat("Down to PitchTier",input = paste(wavdir,round(start,2),".pitch",sep=""), output = paste(wavdir,round(start,2),".tier",sep=""))
        praat("Stylize...", arguments = list(stylres, "Semitones"), input = paste(wavdir,round(start,2),".tier",sep=""), output = paste(wavdir,round(start,2),".tier",sep=""), overwrite = TRUE)
        # calculate the time between subsequent f0 measures to equally distribute all measures over the interval
        measurestep = dur/(nummeas+1)
        seq(from = 1, to = nummeas) -> steps
        # measure f0 and write all information (filename, interval label, etc.) to dataframe
        for (step in steps){
          f0 = as.numeric(praat("Get value at time...", list(sum(rep(measurestep,step))), input = paste(wavdir,round(start,2),".tier",sep=""), simplify = TRUE))
          data[nrow(data)+1,] <- c(wav,label,start,end,sum(rep(measurestep,step)),step,f0,octeff)
          
        }
        # remove files created in the process
        file.remove(paste(wavdir,round(start,2),".wav",sep=""))
        file.remove(paste(wavdir,round(start,2),".pitch",sep=""))
        file.remove(paste(wavdir,round(start,2),".tier",sep=""))
        
      }
    }
  }
}

#### write to csv file ####

# note: the generated dataframe should now be compatible with the script responsible for cluster analysis (called 'data')

# write data to csv file in working directory
write.csv(data, output,sep = ",")